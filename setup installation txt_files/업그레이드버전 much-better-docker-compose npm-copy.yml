# 참고 https://www.youtube.com/watch?v=I980aPL-NRM&t=186s

#composer와 npm artisan 도 포함하기


version: "3.9"
services: 

  web:
    image: nginx:latest
    container_name: nginx
    ports: 
      - "8000:80"
    volumes: 
        - ./default.conf:/etc/nginx/conf.d/default.conf  #최상위 디렉토리에 default.conf만들기
        - ./app:/var/www/html  # app 디렉토리도 생성한다해서 도커 nginx 서버와 매칭
    depends_on:
      - php
      - mysql
    networks:
      - laravel
  
  php:
    # image: php:fpm #이렇게만 적으면 가장 최신버전을 받는다. 명시할 수도 있음 php:8.0-fpm , php:7.4-fpm 
    container_name: php
    volumes:
      - ./app:/var/www/html  #이제 php를 app 디렉토리로 연결
    build:  # 위의 image는 제거
      context: .  # 현재 디렉토리
      dockerfile: PHP.Dockerfile  #PHP.Dockerfile 에서 필요한 것을 읽어와 build 한다 . 그냥 Dockerfile 로 만들고 이름도 Dockerfile해도 됨
    ports: 
      - "9000:9000"
    networks:
      - laravel

  composer:
    image: composer:latest
    container_name: composer
    volumes:
      - ./app:/var/www/html  #원래는 ./app 디렉토리를 컨테이너의 /var/www 까지 연결시켜주지만
      # nginx는 /var/www/html 까지 연결을 해줘야해서 다른 모든 volumns도 /var/www/html까지 만들어준다
    working_dir: /var/www/html #어디에 파일들이 있을 지를 결정
    networks:
      - laravel
    # build & up이 된 후에 
    # 컨테이너안의 컴포저를 통해서 추가 라이브러리를 설치할 수 있다
    #$ cd app
    # 도커 런 커맨드로 composer를 실행할 수 있음 --rm 은 down으로 종료가 되면 자동 제거 된다
    # 컨테이너 안에서 실행되므로 다른컨테이너와는 격리가 되어있는데, 신기하게도 로컬에 연결해놨기 때문에 파일들이 설치됨
    #$ docker-compose run --rm composer require tailwindcss(필요한라이브러리)

  npm:
    image: node:13.7 #stable 버전
    container_name: npm
    volumes: 
      - ./app:/var/www/html
    working_dir: /var/www/html
    entrypoint: ['npm']
    networks: 
      - laravel
    #entrypoint: ['npm', '--no-build-links']  # docker-composer run 이 실행될 때 실행된다고 함
    # 뒤에는 옵션인데 '--no-bin-links' 처럼 줄 수 있으나 이번에는 사용 안함
    # npm이 실행될 때 실행이 됨

    # 이제 npm을 추가해서 build && up을 했다면 테스트를 해보는데
    # 로컬에서 하듯이 npm install && npm run dev 로 하는게 아니라 도커로 실행하게 된다
    # 상위 디렉토리로 이동을 해서
    # $ docker-compose run -rm npm install
    # npm으로 로컬에서 하듯이 json파일을 이용 패키지들을 다운 되어 진다
    # 이후 
    # $ docker-compose run --rm npm run dev 
    # 으로 실행을 하면 mix를 진행하게 됨 

  artisan:
    build:
      context: .
        dockerfile: Dockerfile
    container_name: artisan
    volumes:
      - ./app:/var/www/html
    depends_on: # dependency 가 필요 (왜냐하면 db에 계속 입력 수정 삭제등을 해야하니깐..)
      - mysql
    working_dir: /var/www/html
    entrypoint: ['/var/www/html/artisan']  # npm에서 설정한 것 처럼 entrypoint를 지정해주는데 
    # docker-composer run이 할 때 실행이 된다
    # 대신에 전역으로 설정이 되어있는 명령어가 아니기 때문에 전체 경로를 입력한다
    networks: 
      - laravel

    # 원래는 artisan 컨테이너가 없다면 
    # docker-compose exec php php /var/www/html/artisan migrate 이런식으로 
    # docker-compose exec를 실행하고 php 컨테이너로 해서 php /경로/artisan migrate를 시켰는데..
    # 비교를 위해 만약 로컬이라면 (php artisan migrate)
    
    # build && up 이후에 
    # docker-compose run --rm artisan migrate 로 하면 된다! 오 굿!! (짧아짐!!)

  mysql:
    image: mariadb:latest
    container_name: mysql
    restart: unless-stopped
    ports:
      - "3306:3306"
    environment:
      MYSQL_ROOT_PASSWORD: my-secret-pw 
      MYSQL_DATABASE: tutorial
      MYSQL_USER: tutorial
      MYSQL_PASSWORD: secret
      SERVICE_TAGS: dev 
    volumes:
      - ./mysqldata:/var/lib/mysql
    networks:
      - laravel
  
  phpmyadmin:
    image: phpmyadmin
    container_name: phpmyadmin
    networks: 
      - laravel
    restart: always
    ports:
      - "8080:80"
    environment:
      - PMA_ARBITRARY=1
      - PMA_HOST= mysql
      - PMA_PORT= 3306

networks:
  - laravel:

volumes:
  mysqldata: {}
