# openCV 기본 색 처리 
8 bit 로 1 byte로 구성을 하는데, 
8bit로 (uint8) 로 구성하는 이유는 

2의 8승까지 표현이 가능하기 때문이다. 그러면 256이 나오는데 0~255까지 표현이 된다.

1를 표현한다고 하면

| 8 | b| i | t | | | | |
| -- | -- | -- | -- | -- | -- | -- | -- |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

으로 들어가게 된다 

<br>

255을 표현하게 되면 

| 8 | b| i | t | | | | |
| -- | -- | -- | -- | -- | -- | -- | -- |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

<br/>

# Bitwise AND Operation
opencv에서 라인 탐색을 하는 것을 진행하다보면  
사진에서 차선 외에 필요없는 배경 부분을 지우고  
필요한 부분을 사용하기 위한 마스크 씌우는 작업을 하는데  

먼저 원본 이미지를 gray scale로 만든다음에   
이미지의 크기 그대로 검정색 (0으로) 바꿔서 검정색 이미지를 만들고 
이때 넘파이의 zeros_like() 메소드를 사용
```py
image_gray = cv2.cvtColor(image_color, cv2.COLOR_BGR2GRAY)
blank = np.zeros_like(image_gray)
```

관심없는 영역을 0으로 넣어주면 8비트가 모두 0이 되고   
이제 & (and) 연산자로 처리하면  
둘 다 True (1)이어야지 1이 되는데,   
이미 0이 되면 있으면 어떤 값이 와도 False (0)이 되버린다 

예:
 
| | 8 | b| i | t | | | | |
|--| -- | -- | -- | -- | -- | -- | -- | -- |
|관심없는영역 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
|gray이미지 | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 0 |
|bitwise & | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |


<br>

반면에 보여줘야할 영역인 관심영역은 1로 만들어 주면   
또 AND연산을 하면 관심영역은 원래 gray scale의 색 그대로 나오게 된다 


| | 8 | b| i | t | | | | |
|--| -- | -- | -- | -- | -- | -- | -- | -- |
|관심 영역 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
|gray이미지 | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 0 |
|bitwise & | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 0 |


<br>

그래서 2차원으로 관심있는 부분을 2차원으로 설정해서 만들어 준다  
```py
ROI = np.array( [ [ (0, 400), (300, 250), (450, 300), (700, 426) ] ], dtype= np.int32)

mask = cv2.fillPoly(blank, ROI, 255)
```

위에서 만든 검정색 이미지인 blank에다가   
마스크를 생성해주는데 ROI변수는 특정부분 (내가 관심있는 부분이다)에는 흰색이 들어가진다  

이제 **btiwise AND** 연산을 할 시간이다   
위에서 예를 든 것 처럼 비트 단위로 앤드 연산을 하게되고 

```py
masked_image = cv2.bitwise_and(image_gray, mask)
cv2.imshow('masked_image', masked_image)
```
위 코드를 실행시키고 사진을 화면에 출력하게 되면  
살리고 싶었던 부분만 사진이 나오고 나머지 배경 부분은   
검정색으로 나오는 것을 확인할 수 있다. 



