#include <stdio.h>
int main() {
/* 배열과 포인터
    int arr[5];
    int a;
    int *ptr;
    ptr = &a;
    ptr = arr; //배열자체는 배열의 첫번째 요소를 가리키는 주소값: &가 필요없다
    // &arr[0] == arr == ptr
    // arr[0] == ptr[0]
    // 포인터 변수에 숫자를 더해서 접근
    //(ptr + 0) == (arr + 0)  :첫 번재 요소
    //(ptr + 1) == (arr + 1) : 두 번째 요소
    //. *(ptr + 0) == (arr +0) == arr[0] //간접 참조 연산자 (* asterisk)를 사용해도 같은 결과
    //. *(ptr + 0) == (arr +0) == arr[0]  
    // 증간연산자도 사용가능
    //. *(ptr +0) 하나 증가면 *(ptr +1) 를 ptr++ 식으로 처리 가능 : 주소값이 바뀌는 것 그러므로 가능
    // 단, arr은 배열인데 *(arr + 0)은 가능하나 1= arr++ 는 불가능하다 (arr++자체는 변수값 자체를 변화시키기 때문에 안됨): 배열명은 값을 바꿀 수 없음
    // 예: int a = 10
    // 예: a + 1 은 a +1 을 더하지만 a 자체를 바꾸지 않음
    // 예: a++은 a에 +1 해서 a자체를 바꾸는 것 
*/

/* 참고: 포인터와 배열들
    int * arr[3] 포인터 배열
    int ** p_arr 더블 포인터
    int arr[3][4] 2차원 배열
    int (*p_arr)[4] 배열 포인터 == p_arr[0][2] 처럼 배열 처럼 사용할 수 있음 //?주의할 점은 ()괄호를 빼면 포인터 배열변수가 되므로 주의한다
*/

    int ary[3];
    int i;

    *(ary + 0) = 10;  //. *(ary + 0)은 포인터 연산식이라고 하며 ary는 배열이므로 배열 주소값을 가지므로 +0 이면 ary[0] 같음
    *(ary + 1) = *(ary + 0) + 10;

    printf("세 번째 배열 요소에 키보드 입력: ");
    scanf("%d", ary + 2);

    for(i=0; i< 3; i++){  // 또는 for(i=0; i<ary[i]; i++)
        printf("%5d", *(ary + i));
    }
    
    return 0;

}