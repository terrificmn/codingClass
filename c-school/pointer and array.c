#include <stdio.h>
int main() {
/* 배열과 포인터
    int arr[5];
    int a;
    int *ptr;
    ptr = &a;
    ptr = arr; //배열자체는 배열의 첫번째 요소를 가리키는 주소값: &가 필요없다
    // arr[0] == arr == ptr
    // arr[0] == ptr[0]
    // 포인터 변수에 숫자를 더해서 접근
    //(ptr + 0) == (arr + 0)  :첫 번재 요소
    //(ptr + 1) == (arr + 1) : 두 번째 요소
    // 증간연산자도 사용가능
    // *(ptr +0) 하나 증가면 *(ptr +1) 를 ptr++ 식으로 처리 가능 : 주소값이 바뀌는 것 그러므로 가능
    // 단, arr은 배열인데 *(arr + 0)은 가능하나 1= arr++ 는 불가능하다 (arr++자체는 변수값 자체를 변화시키기 때문에 안됨)
    // **배열명은 값을 바꿀 수 없음
    // 예: int a = 10
    // 예: a + 1 은 a +1 을 더하지만 a 자체를 바꾸지 않음
    // 예: a++은 a에 +1 해서 a자체를 바꾸는 것 
*/

///// 배열을 포인터처럼 주소 연산 하기
///// 배열을 *을 붙여서 포인터 처럼 사용하는데, 이는 배열 자체가 주소값을 가지고 있으니 포인터가 하는 방식대로 할 수 있음
    int arr[3] = {1, 2, 3};
    int arr2[3] = {1, 2, 3};
    int *parr = arr;  //포인터 parr에 배열을 주소값으로 할당
    //parr + 0 == arr[0] == arr + 0
    //parr + 1 == arr[1] == arr + 1
/*
    //!중요:  주소 VS 값 참조
    //주소값으로 비교하면 아래와 같다, 각각 주소를 의미 //?주소값 
    parr + 0 == arr + 0 == &arr[0]  // 포인터 자체가 주소이므로 *을 안붙이고 사용, arr[0]은 주소값을 말해주기 위해서 &붙임
    //실제 값을 참조하기 위해서는  *를 붙인다. //** 실제로는 이것을 많이 쓰게 됨, !1값을 참조할 때
    *(parr + 1) == *(arr + 1) == arr[i]
*/


/* 참고: 포인터와 배열들
    int * arr[3] 포인터 배열
    int ** p_arr 더블 포인터
    int arr[3][4] 2차원 배열
    int (*p_arr)[4] 배열 포인터 == p_arr[0][2] 처럼 배열 처럼 사용할 수 있음 
    //?주의할 점은 ()괄호를 빼면 포인터 배열변수가 되므로 주의한다
*/

    int ary[3];
    int i;

    *(ary + 0) = 10;  //. *(ary + 0)은 포인터 연산식이라고 하며 ary는 배열이므로 배열 주소값을 가지므로 +0 이면 ary[0] 같음
    *(ary + 1) = *(ary + 0) + 10;

    printf("세 번째 배열 요소에 키보드 입력: ");
    scanf("%d", ary + 2);

    for(i=0; i< 3; i++){  // 또는 for(i=0; i<ary[i]; i++)
        //printf("%5d", ary[i]); // ** 아래 코드와 같은 것 == *(ary + 1)
        printf("%5d", *(ary + i));
        // printf("* %d *", (ary + i)); //?주의: 이런식으로 * 주소값을 참조하지 않으면 주소가 나옴

    }

////////////////포인터를 이용해서 뒤집기 
    int arr[6] = {1,2,3,4,5,6};
    printf("%d\n", arr[0]);
    int *fp = &arr[0];  //포인터에 주소값을 넣어준다, 
    //** (배열명이 주소를 의미하지만, 인덱스가 아닌 배열명이여야 한다) 하지만 여기에서 값이 아닌 주소값을 넣어준다, 인덱스 방식
    // int *fp = arr; 문제가 없는 코드
    // int *fp = arr[0]; 이렇게 하면 에러가 남, 배열명은 주소값을 찾지만 arr[0]번째는 알 수 없으므로 에러
    int *lp = &arr[5];  
    int temp;
    
    for(i=0; i< 3; i++) {
        temp = *fp;
        *fp = *lp;
        *lp = temp;
        fp += 1;
        lp -= 1;
    }

    for(i=0; i< 6; i++) {
        printf("%d ", arr[i]); //출력
    }

///////////포인터 배열의 사용, 문자열과 일반 변수의 주소값 참조의 차이점!!
    int a = 10, b = 20, c = 30;
    int * p_arr[3] = {&a, &b, &c}; // 포인터 배열 선언  // 포인터 배열들에 주소값들을 가진다
    printf("%d ", *(p_arr[0]));  //** 포인트배열에는 주소가 들어가 있으므로 arr[0] 을 값을 참조하기 위해 *로 묶어준다
    printf("%d ", *p_arr[1]);
    
    char * p_arr2[3] = {"dog", "cat", "bird"}; //문자열은 주소값이기 때문에 &를 사용 안함. 바로 값을 할당 할 수 있다 (이놈 헛갈림)
    // 자체가 주소값
    printf("%s, %s, %s", p_arr2[0], p_arr2[1], p_arr2[2]); 
    //! 문자열은 주소값 자체지만 &을 안 붙이고 할당하는데 참조 할 때도 마찬가지로 *참조 사용을 안한다)
    //! 일단 암기: 문자열은 자체가 주소값, 그래서 &을 안 사용하고 참조할 때도 &을 사용안함
    // 일반 변수에서는 &을 거쳐서 주소값을 참조한다고 생각한다면,..
    // 문자열상수는 &을 안 거치고 문자열자체가 주소값이 되어버린다고 생각하면 좋다
    // 그래서 &가 없어서 중간에 거치는 것이 없으니깐 값을 참조할 때도 & 없이 사용하게 된다!

    return 0;

}