# Wheeled mobile robots
Wheeled mobile robots ì—ëŠ” Holonomic (omnidirectional) ë˜ëŠ” nonholonomic ë°©ì‹ì´ ìžˆë‹¤.   


Holonomic: omniwheels ë˜ëŠ” mecanum wheels ê°€ ìžˆë‹¤. ì˜†ìœ¼ë¡œ ì´ë™ì´ ê°€ëŠ¥í•˜ë‹¤ 

Nonholonomic: ìžë™ì°¨, ì „í†µì  ë°©ì‹ì˜ íœ  ë“±ì´ ìžˆê³ , ì˜†ìœ¼ë¡œ ì›€ì§ì¼ ìˆ˜ê°€ ì—†ë‹¤

## chassisì˜ ì†ë„
ë¨¼ì € ë¡œë´‡ì˜ x axis, y axis, í—¤ë”©ë°©í–¥ì¸ angular z axisê°€ ìžˆëŠ”ë° (ì¤‘ì‹¬ì—ì„œ zì¶•)   
ì´ë¥¼ í†µí•´ì„œ chassisì˜ ì†ë„ë¥¼ êµ¬í•˜ê²Œ ëœë‹¤. **íœ ì˜ ì†ë„ëŠ” ì•„ë‹ˆë‹¤**

![ë¡œë´‡ì˜ x,y,zì¶•](./img/mpo500.png)

ìœ„ì˜ coordinateë¥¼ í†µí•´ì„œ q = (ì•ŒíŒŒ, x, y) ê°€ ë˜ê²Œ ëœë‹¤. (ìƒ¤ì‹œì˜ ì†ë„(twistë¥¼ ð‘£b) ë¡œ ì‹ìœ¼ë¡œ í‘œì‹œí•˜ë©´..)   
ð‘£b = (Ï‰bz, ð‘£bx, ð‘£by) 

> ð‘£ëŠ” vee ë¡œ ë°œìŒ, (vì™€ ë¹„ìŠ·) vectorë¥¼ ì˜ë¯¸í•  ê²½ìš° ë§Žì´ ì‚¬ìš©   
Ï‰ ëŠ” ì˜¤ë©”ê°€, ê·¸ë¦¬ìŠ¤ì†Œë¬¸ìž, angular velocityë¥¼ ì§€ì¹­í•  ë•Œ ë§Žì´ ì‚¬ìš©



## Kinematic model
4ë°”í€´ì˜ mecanum ì˜ ëª¨ë°”ì¼ ë¡œë´‡ kinematic model  

![ì´ë¯¸ì§€](./img/mecanum_kenematic.png)

ð‘¢ ëŠ” íœ ì˜ driving ì†ë„ì˜ ëŒ€í•œ vector  
ð‘Ÿ ì€ íœ ì˜ radius   
ð‘™ ê³¼ ð‘¤ ì€ ìƒ·ì‹œ (chassis)ì˜ dimensions   
ð‘™ ì€ íœ ì˜ ì¤‘ì ì—ì„œ x axis ë¡œ ë¡œë´‡ ìƒ¤ì‹œ ì¤‘ì‹¬ê¹Œì§€ì˜ ê±°ë¦¬ 
--(íœ ë² ì´ìŠ¤ë¼ê³  ìƒê°í•  ìˆ˜ ìžˆëŠ” íœ (front) ì¤‘ì ê³¼ íœ (rear)ì˜ ê±°ë¦¬ì˜ ë°˜ì ˆì´ ë¨)    

ð‘¤ íœ ì˜ ì¤‘ì ì—ì„œ y axisë¡œ ë¡œë´‡ ìƒ¤ì‹œ ì¤‘ì‹¬ê¹Œì§€ ê±°ë¦¬   
--(frontë‚˜, rearë¥¼ y axisê¸°ì¤€ìœ¼ë¡œ íœ (left)ì˜ ì¤‘ì ì—ì„œ íœ (right) ì¤‘ì ê¹Œì§€ ê±°ë¦¬ì˜ ë°˜ì ˆ)

ð›¾ ëŠ” ìŠ¬ë¼ì´ë”©ì„(free sliding occurs) í•˜ëŠ” ê°ë„   
free slidingì€ diagonal ì›€ì§ìž„. ì¦‰, ëŒ€ê°ì„ ìœ¼ë¡œ ì›€ì§ì´ëŠ” ê²ƒì„ ì˜ë¯¸í•˜ëŠ” ë“¯ í•˜ë‹¤   


![ì´ë¯¸ì§€](./img/mecanum_robot.png)

## íŒŒì´ì¬ ì½”ë“œë¡œ í‚¤ë„¤ë§ˆí‹±ì„ functionìœ¼ë¡œ êµ¬í˜„

```
    â”    â”“       â”             â”“   
    â”ƒ u1 â”ƒ       â”ƒ -l - w 1 -1 â”ƒ â”     â”“    
    â”ƒ u2 â”ƒ       â”ƒ 1 + w  1  1 â”ƒ â”ƒ wbz â”ƒ   
u = â”ƒ u3 â”ƒ = 1/r â”ƒ l + w  l -1 â”ƒ â”ƒ ubx â”ƒ   
    â”ƒ u4 â”ƒ       â”ƒ l - w  1  1 â”ƒ â”ƒ uby â”ƒ   
    â”–    â”š       â”–             â”š â”–     â”š   
```

```py
def twist2wheels(wz, vx, vy):
    l = 0.500/2
    r = 0.254/2
    w = 0.548/2
    H = np.array([[-l-w, 1, -1],
                  [ l+w, 1,  1],
                  [ l+w, 1, -1],
                  [-l-w, 1,  1]]) / r
    twist = np.array([wz, vx, vy])
    twist.shape = (3,1)
    u = np.dot(H, twist)
    return u.flatten().tolist()

# numpyë“±ì´ í•„ìš”
import rospy, numpy as np
from std_msgs.msg import Float32MultiArray

rospy.init_node('make_turn', anonymous=True)
pub = rospy.Publisher('wheel_speed', Float32MultiArray, queue_size=10)
rospy.sleep(1)

u = twist2wheels(wz=1.5, vx=1, vy=0)
msg = Float32MultiArray(data=u)
pub.publish(msg)
rospy.sleep(1)
stop = [0,0,0,0]
msg = Float32MultiArray(data=stop)
pub.publish(msg)

```

ì˜ˆì œì— ì‚¬ìš©ëœ ë¡œë´‡ì˜ íœ  ì§€ë¦„ì€ 254mm, ìœ„ì˜ ê·¸ë¦¼ì„ ì°¸ê³ í•˜ìž..

> l, r, wë¥¼ 2ë¡œ ë‚˜ëˆˆê²ƒì€ ìœ„ì˜ ê·¸ë¦¼ì„ ë³´ë©´ ë” ì´í•´ê°€ ì‰½ë‹¤.  
robotì˜ íœ ë² ì´ìŠ¤ë¼ê³  í•  ìˆ˜ ìžˆëŠ” robot's length ë¶€ë¶„ì˜ ê¸¸ì´ë¥¼ ì‚¬ìš©ì„ í•˜ëŠ”ë°   
ë¡œë´‡ kinematic modelì„ ë³´ê²Œ ë˜ë©´ *l* ì˜ ì›€ì§ìž„ì€ ë¡œë´‡ ì¤‘ì‹¬ì—ì„œ íœ  ì¤‘ì‹¬ê¹Œì§€ì˜    
ì›€ì§ìž„ì´ë‹ˆê¹ robot's length (ë§ˆì¹˜ íœ ë² ì´ìŠ¤)ì—ì„œ 2ë¥¼ ë‚˜ëˆ ì£¼ê²Œ ë˜ê³ ,    
ì´ëŠ” wì™€, radiusì™€ë„ ê°™ì€ ë°©ì‹ì´ë‹ˆê¹ ë‹¤ë“¤ ë°˜ì ˆì„ ì‚¬ìš©í•´ì„œ ë‚˜ëˆ ì¤€ë‹¤   

ì²˜ìŒ np.array()ë¡œ ë§Œë“  H ëŠ” 2ì°¨ì› ë°°ì—´ë¡œ ë§Œë“¤ì–´ ì¤€ë‹¤.   
ê°ê°ì˜ ë°°ì—´ì— 3ê°œì”© ìš”ì†Œê°€ ë“¤ì–´ê°€ê²Œ ëœë‹¤. row:4, column:3   

twist ê°™ì€ ê²½ìš°ì—ëŠ” ë°°ì—´ë¡œ ë§Œë“  í›„ì— shapeë©”ì†Œë“œë¥¼ í†µí•´ì„œ 3x1 ì§œë¦¬ 2ì°¨ì› ë°°ì—´ë¡œ ë§Œë“¤ì–´ ì¤€ë‹¤   
ì´ìœ ëŠ” wz, vx, vy ë¥¼ H arrayì— (ê³µì‹ì— ì˜í•´) ê³±í•´ì¤˜ì•¼ í•˜ê¸° ë•Œë¬¸ -- ì´ìœ ëŠ” Hê°€ 2ì°¨ì› ë°°ì—´ì´ì–´ì„œ ë˜‘ê°™ì´ ë§Œë“¤ì–´ ì£¼ê³    
twist 2ì°¨ì› ë°°ì—´ì˜ ìš”ì†Œ[0], [1], [2] ì´ ê°ê° H [0], [1], [2]ì— ê³±í•´ì£¼ê²Œ ëœë‹¤.   

ì˜ˆë¥¼ë“¤ì–´ [ [-l-w, 1, -1], ...ìƒëžµ ] ê³¼ [ [wz], [vx], [vy] ] ë¥¼ ê³±í•˜ê²Œ ë¨ 

 íŒŒì´ì¬ì—ì„œëŠ” ì´ ë¶€ë¶„ì´ np.dot(H, twist)ë¡œ í•´ê²°í•œë‹¤. H, twsit ìš”ì†Œë¥¼ ê°ê° ê³±í•´ì£¼ê³  2ì°¨ì› ë°°ì—´ ìš”ì†Œë¼ë¦¬ëŠ” ë‹¤ ë”í•´ì¤€ë‹¤   

 ë§ˆì§€ë§‰ìœ¼ë¡œ 2ì°¨ì› ë°°ì—´ì„ ë¦¬ìŠ¤íŠ¸ë¡œ ë°”ê¿”ì£¼ê²Œ ëœë‹¤. ( np.flatten().tolist() )


ë¦¬í„´ ê°’ìœ¼ë¡œ 4ê°œ ë°”í€´ì˜ ì†ë„ì¸ uê°€ ë‚˜ì˜¤ê²Œ ëœë‹¤. (4ê°œ ìš”ì†Œ ê°’)   

## teleopì„ ì‚¬ìš©í•  ê²½ìš°
ros ì˜ Twsit ë©”ì„¸ì§€ë¥¼ ì‚¬ìš©í•  ê²½ìš° , linear ê°’ê³¼ angular ê°’ì„ ì‚¬ìš©í•˜ê²Œ ë˜ëŠ”ë°  

ëŠ˜ í•˜ë˜ ë°©ì‹ì²˜ëŸ¼, differential drive ë°©ì‹ì—ì—ì„œ 2ê°œì˜ ë°”í€´ë¡œ êµ´ë¦¬ëŠ” ê²ƒì„ ìƒê°í•˜ê³   
ë‹¨ì§€, differential drive ë°©ì‹ì¸ 2ë°”í€´ êµ´ë¦¼ì—ì„œëŠ” linear.yë¥¼ ì´ìš©í•´ì„œ yì¶•ìœ¼ë¡œ ì´ë™ì„ í•  ìˆ˜ ì—†ê³   
ë‹¨ì§€ íšŒì „ ì›€ì§ìž„ì¸ angular.z ë°©í–¥ì„ ì›€ì§ì´ëŠ” ê²ƒì´ ìžˆì„ ë¿ì¸ë°   

ì˜†ìœ¼ë¡œ ì´ë™í•˜ëŠ” ê²ƒì„ zë¡œ ì°©ê°ì„ í•˜ê²Œ ë˜ì—ˆë‹¤. ë¬¼ë¡  ìž‘ë™ì—ëŠ” ìš°ì—°ížˆ ë¬¸ì œëŠ” ì—†ì—ˆì§€ë§Œ   
ê°œë… ìžì²´ê°€ í‹€ë ¸ë‹¤ëŠ” ê²ƒì„ ì•Œê²Œë¨  

mecanumì—ì„œëŠ” yì¶•ìœ¼ë¡œë„ ì´ë™ì´ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— kinematic modelì— ì ìš©ì„ í•  ë•Œ linear.y ê°’ì„ ì£¼ë©´ ëª¨í„°ì˜ ê°’ì„ ê³„ì‚° í•´ì£¼ë‹ˆ  
yì˜ ê°’ë§Œ ë„˜ê¸¸ ìˆ˜ ìžˆê²Œ í•˜ê³    
íšŒì „ ì›€ì§ìž„ì´ í•„ìš”í•  ê²½ìš°ì—ëŠ” x, zê°€ ë‘˜ë‹¤ ìžˆì–´ì•¼ í•˜ê³ , zê°’ì´ ì¡°ê¸ˆ ë” ì»¤ì•¼í•  ë“¯ í•˜ê³     
íƒ±í¬ íšŒì „ ê°™ì´ íšŒì „ì„ í•˜ëŠ” ê²½ìš°ì—ëŠ” z ë°©í–¥ë§Œ ê°’ì„ ì¤˜ì„œ ì´ë™í•  ìˆ˜ ìžˆê²Œ í•œë‹¤


## ëª¨í„° ì •ë ¬
ì‹¤ì œ kinematic model ì—ì„œ ì •ì˜ëœ ëª¨í„°ì˜ ìˆœì„œëŠ”   
ìœ„ì˜ u = [ u1, u2, u3, u4 ]  í•˜ëŠ” ë¶€ë¶„ì—ì„œ ì‹¤ì œ ëª¨í„°ì˜ ìˆœì„œëŠ”    
ìœ„ì˜ ê·¸ë¦¼ì„ ì°¸ê³ í•´ë³´ë©´ ì•Œê² ì§€ë§Œ  

ì•„ëž˜ì˜ ìˆœì„œë¡œ ë˜ì–´ ìžˆë‹¤ (clockwise)
    [m1]    [m2]   
        ì„¼í„°   
    [m4]    [m3]   

ê·¸ëž˜ì„œ u ì— ê´€ë ¨í•´ì„œ arrayë¥¼ ë§Œë“¤ ë•Œ m1, m2, m3, m4 ìˆœìœ¼ë¡œ ë§Œë“¤ì–´ ì¤˜ì•¼ì§€ ë§žëŠ” ê²°ê³¼ê°€ ëœë‹¤ 

í•˜ì§€ë§Œ ì‹¤ì œ ëª¨í„°ê°€ ì´ëŸ° ì´ë ‡ê²Œ ë˜ì–´ ìžˆì§€ ì•Šë‹¤ë©´ ìœ„ì˜ ìˆ˜ì‹ê³¼ ë‹¤ë¥¸ ê²°ê³¼ê°€ ë‚˜ì˜¤ë¯€ë¡œ   
ì˜ˆë¥¼ ë“¤ì–´ ëª¨í„°ìœ„ ìœ„ì¹˜ì— ë”°ë¼ì„œ ì„œë¡œ ë‹¤ë¥¸ ëª¨í„°ê°€ ì›í•˜ì§€ ì•ŠëŠ” ë°©í–¥ìœ¼ë¡œ ì´ë™í•´ë²„ë¦¬ë¯€ë¡œ   
ì‹¤ì œ ëª¨í„°ë¥¼ í™•ì¸í•œ í›„ì— ëª¨í„° ìœ„ì¹˜ë¥¼ ë°”ê¾¸ê¸° ì–´ë ¤ë‹¤ë©´ arrayì˜ ìˆœì„œë¥¼ ë°”ê¿”ì£¼ë©´ ëœë‹¤   


## íŒŒì´ì¬ interpreter ì‚¬ìš©
í„°ë¯¸ë„ì—ì„œ `python3` ë¥¼ ìž…ë ¥í•œ í•˜ë©´ interpreterí”„ë¡œê·¸ëž¨ì´ ì˜í•´ í•œì¤„ì”© ìž…ë ¥í•´ì„œ í…ŒìŠ¤íŠ¸ í•´ë³¼ ìˆ˜ê°€ ìžˆë‹¤    

ì•„ëž˜ëŠ” ìœ„ì˜ í•¨ìˆ˜ë¥¼ ì ìš©í•´ë³¸ ì˜ˆì‹œ, ê°ê° print()í•¨ìˆ˜ë¡œ ê°’ì„ ì¶œë ¥í•´ ë³¼ ìˆ˜ê°€ ìžˆë‹¤ 
```py
Type "help", "copyright", "credits" or "license" for more information.
>>> import rospy, numpy as np
>>> from std_msgs.msg import Float32MultiArray
>>> l = 0.500/2
>>> r = 0.254/2
>>> w = 0.548/2
>>> H = np.array([ [-l-w, 1, -1], [ l+w, 1, 1], [ l+w, 1, -1], [-l-w, 1, 1] ]) /r
>>> print(H)
[[-4.12598425  7.87401575 -7.87401575]
 [ 4.12598425  7.87401575  7.87401575]
 [ 4.12598425  7.87401575 -7.87401575]
 [-4.12598425  7.87401575  7.87401575]]
>>> wz = 1.5
>>> vx = 1
>>> vy = 0
>>> twist = np.array([wz, vx, vy])
>>> print(twist)
[1.5 1.  0. ]
>>> twist.shape = (3,1)
>>> print(twist)
[[1.5]
 [1. ]
 [0. ]]
>>> u = np.dot(H, twist)
>>> print(u)
[[ 1.68503937]
 [14.06299213]
 [14.06299213]
 [ 1.68503937]]
>>> u.flatten().tolist()
[1.6850393700787407, 14.062992125984252, 14.062992125984252, 1.6850393700787407]
>>> 

```

