

a << b 이면 a를 2의 b승만큼( 2 to the power of b) 해준다는 의미

1 << 1 이면 1 * (2^1) 그래서 2가 됨

2 << 1 이면 2 * (2^1) 그래서 4

2 << 2 이면 2 * (2^2) 그래서 8

1 << 8 이면 1 * (2^8) 그래서 256이 된다


하지만 c++에서 ostream 라이브러리의 cout 을 사용할 때면   
bit shift 연산자를 override해서 input/output 출력 기능으로 쓰이기도 한다   

비트로 
1은
```cpp
00000000 00000000 00000000 00000001 = 1
1 << 1 = 00000000 00000000 00000000 00000010 = 2
1 << 8 = 00000000 00000000 00000001 00000000 = 256
```



그 외에도 &, |, ^, 등이 있다
각 AND, OR, NOR이지만. 비트 이므로 
&는 모두 True이어야 1이 된다   
| 는 하나라도 True이면 1이 된다 
^ XOR 연산자, OR의 반대로 작동   (^ power의 의미가 아님)  
<< shift left,   >> shift right

[ 비트와이즈 연산자 보기 bitwise-operators](https://www.programiz.com/cpp-programming/bitwise-operators)

#### & 연산
| A   | B   | A & B |
| --- | --- | ----- |
| 0   | 0   | 0     |
| 0   | 1   | 0     |
| 1   | 0   | 0     |
| 1   | 1   | 1     |

mask 의미로 사용한다고 한다. 1이 있는지 확인할 때 사용   (1이 있어야 true 되므로)


#### | 연산 (or)
| A   | B   | A | B |
| --- | --- | ----- |
| 0   | 0   | 0     |
| 0   | 1   | 1     |
| 1   | 0   | 1     |
| 1   | 1   | 1     |


#### Not 연산자 ~  
Complement 라고도 불림

| A   | ~ A |
| --- | --- |
| 0   | 1   |
| 1   | 0   |

결과를 flip 해버린다  


#### ^ XOR 연산
| A   | B   | A ^ B |
| --- | --- | ----- |
| 0   | 0   | 0     |
| 0   | 1   | 1     |
| 1   | 0   | 1     |
| 1   | 1   | 0     |

or과 같으나,   1과 1 일 경우에는 0으로 리턴


#### shift left <<
char a = 6;
char b = 0;
b = a << 3;

a는 binary로 0110 이를 8bit로 나타내면 0000 0110
여기에서 말그대로 a를 3만큼 left shift하라는 것인데   
3만 왼쪽으로 이동하면  0011 0000 이 된다. left쪽으로 움직인 이후에는 0으로 채워진다   

0011 0000은 48이다.  여기에서 3번 만큼 이동은 2의 3승이 되게 된다.  ( multiply by  power of 2)
싱글 사이클 operation에서 빠르게 가능하다고 함

6 * 2^3 의 결과가 된다 

#### shift right >>
char a = 38;
char b = 0;
b = a >> 2;

마찬가지로 38은 0010 0110 (8bit로 )   
0은 0000 0000   
0010 0110
0000 0000
오른쪽으로 2bit 이동시키면 0000 1001 10 이 되면서 마지막 2개가 짤리게 됨 그래서 0000 1001

> 편하게 1(시작하는 부분) 부터 해주면 됨

1001은 decimal로 9이다   

38 / 2^2 의 결과와 비슷하다. 위의 left shift 에서는 곱하기 였다면 이번에는 나누기의 결과가 된다   
a인 38을 나누면 물론 값은 9.5 이지만 right shift 를 하면서 마지막 비트는 짤리므로 같은 결과가 되지는 않지만 비슷하게 나오게 된다  

아마도 결과값은 나누면서 끝에 값들을 자를 때 사용할 듯??





(number & 0xFF00) >> 8;
의 의미!

어렵지만 정리해야함


