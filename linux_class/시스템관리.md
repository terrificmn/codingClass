세션  
- 특정한 활동을 위한 시간  
- 혹은 특정 사용자가 특정 시간동안 사용한 공간  

터미널/콘솔   
- 컴퓨터 운용을 목적으로 사용자와 컴퓨터가 텍스트를 주고 받는 인터페이스  
- 리눅스의 콘솔은 장치 공간 /dev 에 논리적으로 배정된다  

터미널/콘솔의 종류  
- tty : 일반 콘솔  
콘솔에서 tty 라고 입력하면   
/dev/tty  

- pts : GUI 상태에서 터미널  
/dev/pts/0 로 나오는 것을 알 수 있고  
터미널을 더 많이 생성하면 /dev/pts/1 이렇게 장치이름이 바뀌어서 출력이 된다  


프로세스  
- 디스크의 프로그램이 메모리에 적재되어 CPU에 의해 실행되고 있는 프로그램 인스턴스(사본)  
- 모든 프로세스(PID)는 자식 프로세스라는 서브 프로세스를 생성가능  
    - 자식을 관리하는 프로세스는 부모프로세스 (PPID)  
- 부모 프로세스가 죽으면 자식 프로세스도 죽는다  
- 안죽는 자식 프로세스도 있는데 이를 좀비 프로세스라고 함  
- 상태  
    - Foreground Process : 사용자와 상호작용하는 프로세스 (화면상에 보임)  
    - Background Process : 실행되었지만 눈에 보이지 않고, 내부적으로만 동작하는 프로세스  

- systemd 프로세스에 의해 모든 자식 프로세스가 관리됨 (시스템데몬)  
    - $ pstree 를 입력하면 모든 프로세스를 트리형태로 보여준다  


### ps 명령어
전체 프로세스를 보여준다  
```shell
$ps -e
```

full-format listing으로 보여준다
```shell
$ps -f
```

다른세션 보기 
```shell
ps -t pts/0 
```

다른세션은 공간으로도 분리되므로 다른 터미널을 켜놓았다면 다른 세션이 된다  
세션 확인하기는 
```shell
$tty
```
결과 /dev/pts/0 이런식으로 나온다


kill 명령어  
kill -옵션 <PID>
-9옵션은 인정사정없이 죽인다.(종료된다)
```shell
$kill -9 3245
```

터미널을 2개를 띄어놓은 상태에서 세션을 2개를 생성한 후에  
yes명령어를 이용해서 foreground로 작업이 되게 한다
```shell
$yes
```
그러면 무한으로 yes가 출력이 되는데  
이제 다른 터미널로 가서 프로세스를 엿본다
```shell
$ps -t pts/0
```
결과는
PID     TTY     TIME        CMD
2526    pts/0   00:00:01    bash
2944    pts/0   00:00:03    yes

이렇게 나오는데 yes프로세스가 돌아가고 있고 PID는 2944 이다  
그러면 이제 kill을 사용할 수가 있음

```shell
$kill -9 2944
```

그러면 입력이 되자마자 foreground에서 계속 yes를 출력하다가 killed 라는 출력과 함께  
실행이 중단된다

이번에는 kill을 더 연습해볼려면 pts (터미널)이 아닌 콘솔로 접속해서도 해볼 수 있다  
즉, ctrl+alt+F4를 누르면 콘솔이 시작되는데 로그인을 해주자  
가상머신을 사용해도 똑같이 적용된는데 아마도 단축키가 겹쳐서 그러는지  
가상머신 콘솔이 안들어가지고 host컴 centOS 콘솔이 실행되버림;;;  
어쨋든 tty에서 yes 를 실행시켜보고  
ctrl+alt+F1을 눌러서 다시 GUI 환경으로 돌아온다  
그리고 yes 라는 명령어가 실행되고 있는지 확인해본다  
```shell
$ps -ef | grep yes
```

그러면 여기에서 TTY부분에서 tty4 로 나오는 CMD yes 를 찾아서   
kill을 해주면 됨


백그라운드에서 실행이 되게 하기  
명령어 뒤에 & 앤퍼샌드를 붙여준다  
```shell
$yes &
```
이렇게하면 출력할 곳을 지정을 안해줬기 때문에 background에서 작업이 되지만 출력이 터미널 (화면)로 계속나오게 됨  

```shell
$yes > /dev/null &
```


작업중인 것 보기 
```shell
$jobs
```

fg 명령어 사용하기  
kill명령어를 사용한 것과는 다르게 fg는 %를 붙여서 실행을 하게 된다  
jobs 명령어를 사용한 후에  
```
[1]+ Running        yes > /dev/null &
```
요렇게 나오는데 yes명령어가 백그라운드로 작업되고 있는 것을 알 수 있다  
여기에서 나오는 숫자를 통해서 해당 프로세스를 포그라운드 백그라운드로 전환시킬 수 있음  
이때 1번의 숫자로 실행을 시켜주며 백그라운드에서 포그라운드로 바뀜  
```shell
$fg %1
```
이렇게 되면 포그라운드로 진행된 것을 알 수 있음  
여기에서 Ctrl+z 를 눌러서 중단을 해준다 (Stop) kill 되는 것은 아님  

그리고 나서 이번에는 bg 명령어를 이용해서 bg그라운드로 전환시켜줄 수 있음  
다시 jobs를 쳐보면 [1]+ Stopped 라고 나옴  

(이렇게 하는 이유는 단순히 포그라운드와 백그라운드로 전화되는 것을 연습하기 위한 것  
Ctrl+C 를 누르면 실행이 종료가 되므로 Ctrl+Z로 중단시킨것임)  
그러면
```
$bg %1
```
이러면 다시 백그라운드로 실행이 되게 된다  
다시 jobs를 실행하면   
[1]+ Running 으로 바뀐 것을 알 수 있음


최종종료는 kill 로 종료시키면 됨
```shell
$ps -ef | grep yes
$kill -9 <나온PID>
```

주의할점은 현재 같은 세션에서만 적용이 된다  
더 연습을 해볼려면 이번에는 콘솔에서도 한번 해본다 TTY로 전환

